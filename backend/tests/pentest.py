"""
Scripts de test de pÃ©nÃ©tration pour l'application ESA
"""
import requests
import json
import time
from concurrent.futures import ThreadPoolExecutor
import random
import string

BASE_URL = "http://localhost:5000/api"

class PentestSuite:
    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.results = []
        self.session = requests.Session()
    
    def log_result(self, test_name, status, details):
        """Enregistre un rÃ©sultat de test"""
        result = {
            'test': test_name,
            'status': status,  # 'PASS', 'FAIL', 'WARN'
            'details': details,
            'timestamp': time.time()
        }
        self.results.append(result)
        status_icon = 'âœ…' if status == 'PASS' else 'âŒ' if status == 'FAIL' else 'âš ï¸'
        print(f"{status_icon} {test_name}: {details}")
    
    def test_sql_injection_login(self):
        """Test d'injection SQL sur le login"""
        print("\nğŸ” Test: Injection SQL sur login")
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "admin'--",
            "' UNION SELECT * FROM users--",
            "'; DROP TABLE users--"
        ]
        
        for payload in sql_payloads:
            try:
                response = self.session.post(
                    f"{self.base_url}/auth/login",
                    json={'username': payload, 'password': 'test'},
                    timeout=5
                )
                
                if response.status_code == 400 or 'invalide' in response.text.lower():
                    self.log_result(
                        f"SQL Injection - {payload[:20]}",
                        'PASS',
                        f"Protection active (status: {response.status_code})"
                    )
                else:
                    self.log_result(
                        f"SQL Injection - {payload[:20]}",
                        'FAIL',
                        f"Possible vulnÃ©rabilitÃ© (status: {response.status_code})"
                    )
            except Exception as e:
                self.log_result(
                    f"SQL Injection - {payload[:20]}",
                    'WARN',
                    f"Erreur: {str(e)}"
                )
    
    def test_xss_injection(self):
        """Test d'injection XSS"""
        print("\nğŸ” Test: Injection XSS")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<iframe src='javascript:alert(\"XSS\")'>",
        ]
        
        for payload in xss_payloads:
            try:
                # Tester dans diffÃ©rents endpoints
                response = self.session.post(
                    f"{self.base_url}/admin/users",
                    json={'username': payload, 'email': 'test@test.com', 'password': 'test123', 'role': 'etudiant', 'nom': 'Test', 'prenom': 'Test'},
                    headers={'Authorization': 'Bearer invalid_token'},
                    timeout=5
                )
                
                if payload.lower() not in response.text.lower():
                    self.log_result(
                        f"XSS - {payload[:20]}",
                        'PASS',
                        "Payload filtrÃ©"
                    )
                else:
                    self.log_result(
                        f"XSS - {payload[:20]}",
                        'FAIL',
                        "Payload non filtrÃ©"
                    )
            except Exception as e:
                self.log_result(
                    f"XSS - {payload[:20]}",
                    'WARN',
                    f"Erreur: {str(e)}"
                )
    
    def test_brute_force_protection(self):
        """Test de protection contre brute force"""
        print("\nğŸ” Test: Protection contre brute force")
        
        attempts = 10
        blocked = False
        
        for i in range(attempts):
            try:
                response = self.session.post(
                    f"{self.base_url}/auth/login",
                    json={'username': 'admin', 'password': f'wrong{i}'},
                    timeout=5
                )
                
                if response.status_code == 429:
                    blocked = True
                    self.log_result(
                        "Brute Force Protection",
                        'PASS',
                        f"BloquÃ© aprÃ¨s {i+1} tentatives"
                    )
                    break
                time.sleep(0.5)
            except Exception as e:
                pass
        
        if not blocked:
            self.log_result(
                "Brute Force Protection",
                'FAIL',
                f"Non bloquÃ© aprÃ¨s {attempts} tentatives"
            )
    
    def test_rate_limiting(self):
        """Test du rate limiting"""
        print("\nğŸ” Test: Rate Limiting")
        
        # Faire plusieurs requÃªtes rapides
        responses = []
        for i in range(10):
            try:
                response = self.session.get(
                    f"{self.base_url}/health",
                    timeout=2
                )
                responses.append(response.status_code)
                time.sleep(0.1)
            except Exception as e:
                pass
        
        # VÃ©rifier si certaines requÃªtes sont bloquÃ©es
        if 429 in responses:
            self.log_result(
                "Rate Limiting",
                'PASS',
                "Rate limiting actif"
            )
        else:
            self.log_result(
                "Rate Limiting",
                'WARN',
                "Rate limiting peut-Ãªtre non configurÃ©"
            )
    
    def test_authentication_bypass(self):
        """Test de contournement d'authentification"""
        print("\nğŸ” Test: Contournement d'authentification")
        
        # Tester sans token
        endpoints = [
            '/admin/users',
            '/admin/dashboard/stats',
            '/etudiant/notes',
            '/comptabilite/paiements'
        ]
        
        for endpoint in endpoints:
            try:
                response = self.session.get(
                    f"{self.base_url}{endpoint}",
                    timeout=5
                )
                
                if response.status_code == 401:
                    self.log_result(
                        f"Auth Bypass - {endpoint}",
                        'PASS',
                        "Authentification requise"
                    )
                else:
                    self.log_result(
                        f"Auth Bypass - {endpoint}",
                        'FAIL',
                        f"AccÃ¨s possible sans auth (status: {response.status_code})"
                    )
            except Exception as e:
                self.log_result(
                    f"Auth Bypass - {endpoint}",
                    'WARN',
                    f"Erreur: {str(e)}"
                )
    
    def test_authorization_bypass(self):
        """Test de contournement d'autorisation"""
        print("\nğŸ” Test: Contournement d'autorisation")
        
        # Se connecter en tant qu'Ã©tudiant
        login_response = self.session.post(
            f"{self.base_url}/auth/login",
            json={'username': 'etudiant_test', 'password': 'test123'},
            timeout=5
        )
        
        if login_response.status_code == 200:
            token = login_response.json().get('access_token')
            headers = {'Authorization': f'Bearer {token}'}
            
            # Essayer d'accÃ©der Ã  des endpoints admin
            admin_endpoints = [
                '/admin/users',
                '/admin/dashboard/stats',
                '/comptabilite/paiements'
            ]
            
            for endpoint in admin_endpoints:
                try:
                    response = self.session.get(
                        f"{self.base_url}{endpoint}",
                        headers=headers,
                        timeout=5
                    )
                    
                    if response.status_code == 403:
                        self.log_result(
                            f"Authz Bypass - {endpoint}",
                            'PASS',
                            "AccÃ¨s refusÃ© correctement"
                        )
                    else:
                        self.log_result(
                            f"Authz Bypass - {endpoint}",
                            'FAIL',
                            f"AccÃ¨s possible sans autorisation (status: {response.status_code})"
                        )
                except Exception as e:
                    pass
    
    def test_path_traversal(self):
        """Test de path traversal"""
        print("\nğŸ” Test: Path Traversal")
        
        paths = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32",
            "/etc/passwd",
            "....//....//etc/passwd"
        ]
        
        for path in paths:
            try:
                response = self.session.get(
                    f"{self.base_url}/files/{path}",
                    timeout=5
                )
                
                if response.status_code in [400, 403, 404]:
                    self.log_result(
                        f"Path Traversal - {path[:20]}",
                        'PASS',
                        "Protection active"
                    )
                else:
                    self.log_result(
                        f"Path Traversal - {path[:20]}",
                        'FAIL',
                        f"Possible vulnÃ©rabilitÃ© (status: {response.status_code})"
                    )
            except Exception as e:
                pass
    
    def test_csrf_protection(self):
        """Test de protection CSRF"""
        print("\nğŸ” Test: Protection CSRF")
        
        # Tester une requÃªte POST sans token CSRF
        try:
            response = self.session.post(
                f"{self.base_url}/admin/users",
                json={'username': 'test', 'email': 'test@test.com', 'password': 'test123', 'role': 'etudiant', 'nom': 'Test', 'prenom': 'Test'},
                headers={'Authorization': 'Bearer valid_token'},
                timeout=5
            )
            
            if response.status_code == 403 and 'csrf' in response.text.lower():
                self.log_result(
                    "CSRF Protection",
                    'PASS',
                    "Protection CSRF active"
                )
            else:
                self.log_result(
                    "CSRF Protection",
                    'WARN',
                    "Protection CSRF peut-Ãªtre non configurÃ©e"
                )
        except Exception as e:
            self.log_result(
                "CSRF Protection",
                'WARN',
                f"Erreur: {str(e)}"
            )
    
    def test_security_headers(self):
        """Test des headers de sÃ©curitÃ©"""
        print("\nğŸ” Test: Headers de sÃ©curitÃ©")
        
        try:
            response = self.session.get(
                f"{self.base_url}/health",
                timeout=5
            )
            
            headers = response.headers
            security_headers = {
                'X-Content-Type-Options': 'nosniff',
                'X-Frame-Options': 'DENY',
                'X-XSS-Protection': '1; mode=block',
                'Strict-Transport-Security': 'max-age=31536000',
            }
            
            for header, expected in security_headers.items():
                if header in headers:
                    self.log_result(
                        f"Security Header - {header}",
                        'PASS',
                        f"PrÃ©sent: {headers[header]}"
                    )
                else:
                    self.log_result(
                        f"Security Header - {header}",
                        'FAIL',
                        "Header manquant"
                    )
        except Exception as e:
            self.log_result(
                "Security Headers",
                'WARN',
                f"Erreur: {str(e)}"
            )
    
    def test_password_strength(self):
        """Test de validation de la force des mots de passe"""
        print("\nğŸ” Test: Validation de la force des mots de passe")
        
        weak_passwords = [
            '123456',
            'password',
            'admin',
            'test',
            '12345'
        ]
        
        for password in weak_passwords:
            try:
                response = self.session.post(
                    f"{self.base_url}/auth/change-password",
                    json={'old_password': 'test', 'new_password': password},
                    headers={'Authorization': 'Bearer valid_token'},
                    timeout=5
                )
                
                if response.status_code == 400 and 'faible' in response.text.lower():
                    self.log_result(
                        f"Password Strength - {password}",
                        'PASS',
                        "Mot de passe faible rejetÃ©"
                    )
                else:
                    self.log_result(
                        f"Password Strength - {password}",
                        'WARN',
                        "Validation peut-Ãªtre insuffisante"
                    )
            except Exception as e:
                pass
    
    def test_session_management(self):
        """Test de gestion des sessions"""
        print("\nğŸ” Test: Gestion des sessions")
        
        # Se connecter
        login_response = self.session.post(
            f"{self.base_url}/auth/login",
            json={'username': 'admin', 'password': 'admin123'},
            timeout=5
        )
        
        if login_response.status_code == 200:
            token = login_response.json().get('access_token')
            
            # VÃ©rifier l'expiration du token
            import jwt
            try:
                decoded = jwt.decode(token, options={"verify_signature": False})
                exp = decoded.get('exp', 0)
                now = time.time()
                
                if exp > now:
                    self.log_result(
                        "Session Management",
                        'PASS',
                        f"Token valide jusqu'Ã  {time.ctime(exp)}"
                    )
                else:
                    self.log_result(
                        "Session Management",
                        'FAIL',
                        "Token expirÃ©"
                    )
            except Exception as e:
                self.log_result(
                    "Session Management",
                    'WARN',
                    f"Erreur: {str(e)}"
                )
    
    def test_input_validation(self):
        """Test de validation des entrÃ©es"""
        print("\nğŸ” Test: Validation des entrÃ©es")
        
        invalid_inputs = [
            {'email': 'invalid-email'},
            {'email': 'test@'},
            {'telephone': 'abc'},
            {'date_naissance': 'invalid-date'},
        ]
        
        for invalid_input in invalid_inputs:
            try:
                response = self.session.post(
                    f"{self.base_url}/admin/users",
                    json={**invalid_input, 'username': 'test', 'password': 'test123', 'role': 'etudiant', 'nom': 'Test', 'prenom': 'Test'},
                    headers={'Authorization': 'Bearer valid_token'},
                    timeout=5
                )
                
                if response.status_code == 400:
                    self.log_result(
                        f"Input Validation - {list(invalid_input.keys())[0]}",
                        'PASS',
                        "Validation active"
                    )
                else:
                    self.log_result(
                        f"Input Validation - {list(invalid_input.keys())[0]}",
                        'WARN',
                        "Validation peut-Ãªtre insuffisante"
                    )
            except Exception as e:
                pass
    
    def run_all_tests(self):
        """ExÃ©cute tous les tests"""
        print("=" * 60)
        print("ğŸ”’ TESTS DE PÃ‰NÃ‰TRATION - Application ESA")
        print("=" * 60)
        
        self.test_sql_injection_login()
        self.test_xss_injection()
        self.test_brute_force_protection()
        self.test_rate_limiting()
        self.test_authentication_bypass()
        self.test_authorization_bypass()
        self.test_path_traversal()
        self.test_csrf_protection()
        self.test_security_headers()
        self.test_password_strength()
        self.test_session_management()
        self.test_input_validation()
        
        # RÃ©sumÃ©
        print("\n" + "=" * 60)
        print("ğŸ“Š RÃ‰SUMÃ‰ DES TESTS")
        print("=" * 60)
        
        passed = sum(1 for r in self.results if r['status'] == 'PASS')
        failed = sum(1 for r in self.results if r['status'] == 'FAIL')
        warnings = sum(1 for r in self.results if r['status'] == 'WARN')
        
        print(f"âœ… Tests rÃ©ussis: {passed}")
        print(f"âŒ Tests Ã©chouÃ©s: {failed}")
        print(f"âš ï¸  Avertissements: {warnings}")
        print(f"ğŸ“ˆ Score de sÃ©curitÃ©: {(passed / len(self.results) * 100):.1f}%")
        
        return self.results

if __name__ == "__main__":
    suite = PentestSuite()
    results = suite.run_all_tests()
    
    # Sauvegarder les rÃ©sultats
    with open('pentest_results.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    print("\nğŸ“„ RÃ©sultats sauvegardÃ©s dans pentest_results.json")

